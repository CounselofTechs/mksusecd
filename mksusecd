#! /usr/bin/perl

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# package Tmp version 1.0
#
# Create temporary files/directories and ensures they are removed at
# program end.
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
{
  package Tmp;

  use File::Temp;
  use strict 'vars';

  sub new
  {
    my $self = {};
    my $save_tmp = shift;

    bless $self;

    my $x = $0;
    $x =~ s#.*/##;
    $x =~ s/(\s+|"|\\|')/_/;
    $x = 'tmp' if$x eq "";

    my $t = File::Temp::tempdir("/tmp/$x.XXXXXXXX", CLEANUP => $save_tmp ? 0 : 1);

    $self->{base} = $t;

    if(!$save_tmp) {
      my $s_t = $SIG{TERM};
      $SIG{TERM} = sub { File::Temp::cleanup; &$s_t if $s_t };

      my $s_i = $SIG{INT};
      $SIG{INT} = sub { File::Temp::cleanup; &$s_i if $s_i };
    }

    return $self
  }

  sub dir
  {
    my $self = shift;
    my $dir = shift;
    my $t;

    if($dir ne "" && !-e("$self->{base}/$dir")) {
      $t = "$self->{base}/$dir";
      die "error: mktemp failed\n" unless mkdir $t, 0755;
    }
    else {
      chomp ($t = `mktemp -d $self->{base}/XXXX`);
      die "error: mktemp failed\n" if $?;
    }

    return $t;
  }

  sub file
  {
    my $self = shift;
    my $file = shift;
    my $t;

    if($file ne "" && !-e("$self->{base}/$file")) {
      $t = "$self->{base}/$file";
      open my $f, ">$t";
      close $f;
    }
    else {
      chomp ($t = `mktemp $self->{base}/XXXX`);
      die "error: mktemp failed\n" if $?;
    }

    return $t;
  }

  # helper function
  sub umount
  {
    my $mp = shift;

    if(open(my $f, "/proc/mounts")) {
      while(<$f>) {
        if((split)[1] eq $mp) {
          # print STDERR "umount $mp\n";
          ::susystem("umount $mp");
          return;
        }
      }
      close $f;
    }
  }

  sub mnt
  {
    my $self = shift;
    my $dir = shift;

    my $t = $self->dir($dir);

    if($t ne '') {
      eval 'END { umount $t }';

      my $s_t = $SIG{TERM};
      $SIG{TERM} = sub { umount $t; &$s_t if $s_t };

      my $s_i = $SIG{INT};
      $SIG{INT} = sub { umount $t; &$s_i if $s_i };
    }

    return $t;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
use strict;

use Getopt::Long;
use Digest::MD5;
use Digest::SHA;
use File::Find;
use File::Path;
use Cwd 'abs_path';

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 1;

our $VERSION = "0.0";

my @boot_archs = qw ( x86_64 i386 s390x s390 ia64 aarch64 ppc ppc64 ppc64le );
my $magic_id = "7984fc91-a43f-4e45-bf27-6d3aa08b24cf";

sub usage;
sub check_root;
sub susystem;
sub fname;
sub analyze_boot;
sub build_todo;
sub prepare_mkisofs;
sub build_filelist;
sub run_mkisofs;
sub read_sector;
sub write_sector;
sub fix_catalog;
sub relocate_catalog;
sub rerun_mkisofs;
sub run_isohybrid;
sub isols;
sub find_magic;
sub meta_iso;
sub meta_fat;
sub create_initrd;
sub update_initrd;
sub create_cd_ikr;
sub isolinux_add_option;
sub grub2_add_option;
sub update_boot_options;
sub prepare_micro;
sub prepare_nano;
sub prepare_pico;
sub set_mkisofs_metadata;
sub update_content;

my %config;
my $sudo;
my $sudo_checked;
my $opt_create;
my $opt_save_temp;
my $opt_dst;
my $opt_joliet = 1;
my $opt_verbose = 0;
my $opt_efi = 1;
my $opt_hybrid = 1;
my $opt_hybrid_fs = 'iso';
my $opt_hybrid_gpt;
my $opt_hybrid_mbr;
my $opt_check;
my $opt_digest = 'sha1';
my @opt_initrds;
my $opt_boot_options;
my $opt_type;
my $opt_vendor;
my $opt_preparer;
my $opt_application;
my $opt_volume;
my $opt_no_docs = 1;

GetOptions(
  'create|c=s'       => sub { $opt_create = 1; $opt_dst = $_[1] },
  'joliet'           => \$opt_joliet,
  'no-joliet'        => sub { $opt_joliet = 0 },
  'efi'              => \$opt_efi,
  'no-efi'           => sub { $opt_efi = 0 },
  'uefi'             => \$opt_efi,
  'no-uefi'          => sub { $opt_efi = 0 },
  'check'            => \$opt_check,
  'no-check'         => sub { $opt_check = 0 },
  'digest=s'         => \$opt_digest,
  'no-digest'        => sub { $opt_digest = undef },
  'gpt'              => sub { $opt_hybrid = 1; $opt_hybrid_gpt = 1 },
  'mbr'              => sub { $opt_hybrid = 1; $opt_hybrid_mbr = 1 },
  'hybrid'           => \$opt_hybrid,
  'no-hybrid'        => sub { $opt_hybrid = 0 },
  'hybrid-fs=s'      => sub { $opt_hybrid = 1; $opt_hybrid_fs = $_[1] },
  'initrd=s'         => \@opt_initrds,
  'boot=s'           => \$opt_boot_options,
  'micro'            => sub { $opt_type = 'micro' },
  'nano'             => sub { $opt_type = 'nano' },
  'pico'             => sub { $opt_type = 'pico' },
  'volume=s'         => \$opt_volume,
  'vendor=s'         => \$opt_vendor,
  'preparer=s'       => \$opt_preparer,
  'application=s'    => \$opt_application,
  'no-docs'          => \$opt_no_docs,
  'keep-docs'        => sub { $opt_no_docs = 0 },
  'save-temp'        => \$opt_save_temp,
  'verbose|v'        => sub { $opt_verbose++ },
  'version'          => sub { print "$VERSION\n"; exit 0 },
  'help'             => sub { usage 0 },
) || usage 1;

usage 1 unless $opt_create;
usage 1 if $opt_hybrid_fs !~ '^(|iso|fat)$';
usage 1 if defined($opt_digest) && $opt_digest !~ '^(md5|sha1|sha224|sha256|sha384|sha512)$';

if(open my $f, "$ENV{HOME}/.mksusecdrc") {
  while(<$f>) {
    if(/^(\S+?)=\"(.*)\"\s*$/) {
      $config{$1} = $2;
    }
  }
  close $f;
}

if($config{sudo}) {
  $sudo = $config{sudo};
  $sudo =~ s/\s*$/ /;
}

my $tmp = Tmp::new($opt_save_temp);

# my $tmp_mnt = $tmp->mnt('mnt');
my $tmp_new = $tmp->dir('new');
my $tmp_err = $tmp->file('err');
my $tmp_sort = $tmp->file('sort');
my $tmp_exclude = $tmp->file('exclude');
my $tmp_fat = $tmp->file('fat');

my @sources;
my $files;
my $boot;
my $todo;
my $iso_cnt = 0;
my $mkisofs = { command => 'genisoimage' };
my $iso_file;
my $iso_fh;
my $two_runs;
my $add_initrd;
my $has_efi = 0;

my $progress_start = 0;
my $progress_end = 100;
my $progress_txt = 'building:';

if($opt_create) {
  # we might need two mkisofs runs...
  $two_runs = $opt_hybrid && $opt_hybrid_fs;

  $iso_file = $opt_dst;

  for (@ARGV) {
    s#/*$##;
    next if $_ eq "";
    if(-d) {
      push @sources, { dir => $_, real_name => $_, type => 'dir' };
    }
    elsif(-f _) {
      my $t = `file -b -k -L $_ 2>/dev/null`;
      if($t =~ / ISO 9660 CD-ROM /) {
        check_root "Sorry, can't access ISO images; you need root privileges.";
        $iso_cnt++;
        my $d = $tmp->mnt(sprintf("mnt_%04d", $iso_cnt));
        susystem "mount -oro,loop $_ $d";
        push @sources, { dir => $d, real_name => $_, type => 'iso' };
      }
      else {
        die "$_: unsupported source type\n";
      }
    }
    else {
      die "$_: unsupported source type\n";
    }
  }

  die "no sources - nothing to do\n" unless @sources;

  $add_initrd = create_initrd;
  $files = build_filelist;
  $boot = analyze_boot;
  update_content;
  update_initrd;
  update_boot_options;
  $todo = build_todo;
  set_mkisofs_metadata;
  prepare_mkisofs;

  prepare_micro if $opt_type eq 'micro';
  prepare_nano if $opt_type eq 'nano';
  prepare_pico if $opt_type eq 'pico';

  # print "sources = ", Dumper(\@sources);
  # print "boot = ", Dumper($boot);
  # print "todo = ", Dumper($todo);
  # print "mkisofs = ", Dumper($mkisofs);

  if($two_runs) {
    if($opt_hybrid_fs eq 'iso') {
      $progress_end = 50;
    }
    if($opt_hybrid_fs eq 'fat') {
      $progress_end = 33;
    }
  }

  run_mkisofs;

  if($two_runs) {
    rerun_mkisofs;
  }

  fix_catalog;
  relocate_catalog;

  run_isohybrid if $opt_hybrid;

  if(defined $opt_digest) {
    my $chk = $opt_check ? " --check" : "";
    print "calculating $opt_digest...";
    system "tagmedia $chk --digest '$opt_digest' --pad 150 '$iso_file' >/dev/null";
    print "\n";
  }

  if($mkisofs->{partition_start}) {
    system "tagmedia --add-tag  'partition=$mkisofs->{partition_start}' '$iso_file' >/dev/null";
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# usage($exit_code)
#
# Print help text and exit.
#
sub usage
{
  print <<"= = = = = = = =";
Usage: mksusecd [OPTIONS] [SOURCES]
Create SUSE installation CD/DVD.

SOURCES can be directories or ISO image files. All SOURCES are combined
into a single ISO.

General options:

      --version                 Show mksusecd version.
      --verbose                 Show more messages. Can be repeated to log even more.
      --save-temp               Keep temporary files.
      --help                    Write this help text.

Create ISO image:

  -c, --create FILE             Create ISO image from SOURCES.
                                SOURCES are either directories or existing ISO images.
      --joliet                  Use Joliet extensions (default).
      --no-joliet               Don't use Joliet extensions.
      --uefi                    Make ISO UEFI bootable (default).
      --no-uefi                 Don't make ISO UEFI bootable.
      --check                   Tag ISO to be verified before starting the installation.
      --no-check                Don't tag ISO (default).
      --digest DIGEST           Use DIGEST to verify ISO integrity (default: SHA1).
      --no-digest               Don't calculate any digest.
      --gpt                     Add GPT when in isohybrid mode.
      --mbr                     Add MBR when in isohybrid mode (default).
                                Note that when both --mbr and --gpt are specified both
                                MBR and GPT are written - which looks nice but is against
                                the UEFi spec.
      --hybrid                  Create an isohybrid image which is both an ISO and a
                                regular disk image (default).
      --no-hybrid               Create a regular ISO image without extra gimmicks.
      --hybrid-fs FS            Use FS for the disk partition created in hybrid mode. FS
                                can be either "" (empty string) producing a partition
                                starting at offset 0 and extending across the entire ISO
                                image (partitioning tools don't really like this) or
                                'iso' or 'fat' in which case you get a regular partition
                                with an ISO960 or FAT file system (default: 'iso').
      --initrd DIR|RPM          Add directory DIR or package RPM to initrd.
      --no-docs                 Don't include package documentation when updating the initrd
                                This is the default.
      --keep-docs               Include package documentation when updating initrd.
      --boot OPTIONS            Add OPTIONS to default boot options.
      --micro                   Create an ISO with just enough files to test the
                                installation setup. But you can't actually install as
                                all packages have been removed. (Similar to the
                                Network-ISO.)
      --nano                    Create an ISO with just enough files to test the boot
                                process.
      --pico                    Even less than --nano. Keep just the bootloader.
      --volume                  Set ISO volume id.
      --vendor                  Set ISO publisher id.
      --preparer                Set ISO data preparer id.
      --application             Set ISO application id.

Hybrid mode notes:

  Hybrid mode means the image can be used both as an ISO for a DVD or
  directly as a disk image. In other words, there is a partition table
  written on the ISO image, either GPT or MBR.

  If you need UEFI support you will get two paritions: one for the UEFI
  image, one for the entire DVD. If not, you get just one partition covering
  all files.

  There are 2 variants this script supports:

    (1) Partition 1 is the data partition starting at offset 0 and covering
    the entire ISO, partition 2 is the UEFI system parition pointing
    somwhere inside the first partition. This produces an obviously
    inconsistent partition table and partitioning tools really don't like it.

    (2) Partition 1 is a data partition _not_ starting at offset 0 but still
    holding all data files. When you mount it, you see either an ISO9660 or
    a FAT filesystem. If you need UEFI support this partition becomes
    partition 2 and partition 1 points to the UEFI image. Partition 1 and 2
    don't overlap. In this variant a consistent partition table is written.

Configuration files:

  \$HOME/.mksusecdrc
    To access existing ISO image files you will need root privileges. (It
    will be mounted.) There's a 'sudo' config file entry that lets you
    specify a command granting you root privileges. E.g. sudo="foo".

Examples:

  # create foo.iso from /foo_dir
  mksusecd --create foo.iso /foo_dir

  # create foo.iso from /foo_dir, no hybrid mode
  mksusecd --create foo.iso --no-hybrid /foo_dir

  # create foo.iso from old.iso and add files to the initrd
  mksusecd --create foo.iso --initrd /dir_with_new_initrd_stuff --initrd foo.rpm old.iso

  # create foo.iso from old.iso and add some boot option
  mksusecd --create foo.iso --boot 'debug=1' old.iso

= = = = = = = =

  exit shift;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub check_root
{
  my $p;
  my $msg = shift;

  return if $sudo_checked;

  $sudo_checked = 1;

  if(!$>) {
    undef $sudo;
    return;
  }

  chomp($p = `bash -c 'type -p $sudo'`) if $sudo;

  $msg = "sorry, you must be root" if $msg eq "";

  die "$msg\n" if $p eq "";
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub susystem
{
  system $sudo . $_[0];
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub show_progress
{
  my $p = shift;

  return if $progress_end - $progress_start < 1;

  $p = 0 if $p < 0;
  $p = 100 if $p > 100;

  $p = ($progress_end - $progress_start) / 100.0 * $p + $progress_start;

  printf "\r$progress_txt %3d%%", $p;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub fname
{
  if(exists $files->{$_[0]}) {
    return "$files->{$_[0]}/$_[0]";
  }
  else {
    return undef;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub build_filelist
{
  my $files;

  for my $s (@sources) {
    File::Find::find({
      wanted => sub {
        $files->{$1} = $s->{dir} if m#^$s->{dir}/(.+)#;
      },
      no_chdir => 1
    }, $s->{dir});
  }

  return $files;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub analyze_boot
{
  my $boot;

  for (@boot_archs) {
    if(-d fname("boot/$_")) {
      $boot->{$_} = { base => "boot/$_" };

      $boot->{$_}{initrd} = "boot/$_/loader/initrd" if -f fname("boot/$_/loader/initrd");
      $boot->{$_}{initrd} = "boot/$_/isolinux/initrd" if -f fname("boot/$_/isolinux/initrd");
      $boot->{$_}{initrd} = "boot/$_/initrd" if -f fname("boot/$_/initrd");

      $boot->{$_}{kernel} = "boot/$_/loader/linux" if -f fname("boot/$_/loader/linux");
      $boot->{$_}{kernel} = "boot/$_/isolinux/linux" if -f fname("boot/$_/isolinux/linux");
      $boot->{$_}{kernel} = "boot/$_/vmrdr.ikr" if -f fname("boot/$_/vmrdr.ikr");
      $boot->{$_}{kernel} = "boot/$_/linux" if -f fname("boot/$_/linux");

      if(-f fname("boot/$_/loader/isolinux.bin")) {
        $boot->{$_}{bl}{isolinux} = { base => "boot/$_/loader", arch => $_ };
      }
      if(-f fname("boot/$_/isolinux/isolinux.bin")) {
        $boot->{$_}{bl}{isolinux} = { base => "boot/$_/isolinux", arch => $_ };
      }
      if(-f fname("boot/$_/cd.ikr")) {
        $boot->{$_}{bl}{ikr} = { base => "boot/$_/cd.ikr", arch => $_ };
      }
      elsif(-f fname("boot/$_/suse.ins")) {
        $boot->{$_}{bl}{ikr} = { base => "boot/$_/cd.ikr", arch => $_, ins => "boot/$_/suse.ins" };
      }
      if(-d fname("boot/$_/grub2-efi")) {
        $boot->{$_}{bl}{"grub2-efi"} = { base => "boot/$_/grub2-efi", arch => $_ };
      }
      if(-f fname("boot/$_/efi")) {
        $boot->{$_}{bl}{efi} = { base => "boot/$_/efi", arch => $_ };
      }
    }
    if(-f fname("ppc/bootinfo.txt")) {
      $boot->{ppc} = { base => "ppc", arch => $_ };
      # ...
    }
  }
  if(-d fname("EFI/BOOT")) {
    $boot->{efi} = { base => "EFI/BOOT" };
  }

  return $boot;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub build_todo
{
  my $todo;
  my %iso_arch;

  # legacy El-Torito x86 boot
  # In theory more than one entry could be created, but BIOSes don't really
  # expect that...
  for (sort keys %$boot) {
    if($boot->{$_}{bl}{isolinux}) {
      $iso_arch{$_} = { isolinux => $boot->{$_}{bl}{isolinux} };
    }
  }

  # ... so we just pick one.
  if(%iso_arch) {
    $_ = (sort keys %iso_arch)[-1];
    push @$todo, $iso_arch{$_};
    if(keys %iso_arch > 1) {
      print "More than one El Torito legacy boot entry detected, choosing $_.\n";
    }
  }

  # standard UEFI boot
  for (sort keys %$boot) {
    if($boot->{$_}{bl}{efi}) {
      push @$todo, { efi => $boot->{$_}{bl}{efi} };
    }
  }

  # s390 also uses el-torito 
  for (sort keys %$boot) {
    if($boot->{$_}{bl}{ikr}) {
      push @$todo, { ikr => $boot->{$_}{bl}{ikr} };
    }
  }

  return $todo;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub copy_file
{
  my $f = fname($_[0]);
  my $n;

  return unless defined $f;

  if(-d $f) {
    $n = "$tmp_new/$_[0]";
    system "mdir -p '$n'";
  }
  elsif(-f $f) {
    if($_[0] =~ m#(.+)/([^/]+)#) {
      $n = "$tmp_new/$1/$2";
      system "mkdir -p '$tmp_new/$1'; cp '$f' '$tmp_new/$1'";
    }
    elsif($_[0] !~ m#/#) {
      $n = "$tmp_new/$_[0]";
      system "cp '$f' '$tmp_new'";
    }

    push @{$mkisofs->{exclude}}, $f;
    system "chmod u+w '$tmp_new/$_[0]'";
  }

  # update file location database
  if(defined $n) {
    my $x = $n;
    if($x =~ s#/$_[0]$##) {
      $files->{$_[0]} = $x;
      # print "$_[0] -> $x\n";
    }
  }

  return $n;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub prepare_mkisofs
{
  my $iso_catalog;

  # general options
  $mkisofs->{options} .= " -l -r -pad -input-charset utf8 -o '$iso_file'";
  $mkisofs->{options} .= " -V '" . substr($opt_volume, 0, 32) . "'";
  $mkisofs->{options} .= " -A '" . substr($opt_application, 0, 128) . "'";
  $mkisofs->{options} .= " -p '" . substr($opt_preparer, 0, 128) . "'";
  $mkisofs->{options} .= " -publisher '" . substr($opt_vendor, 0, 128) . "'";
  $mkisofs->{options} .= " -J -f" if $opt_joliet;

  # special loader options
  for (@$todo) {
    my $t = (keys %$_)[0];

    if($t eq 'isolinux') {
      copy_file "$_->{$t}{base}/isolinux.bin";
      push @{$mkisofs->{sort}}, "$tmp_new/$_->{$t}{base}/boot.catalog 4";
      # push @{$mkisofs->{sort}}, fname("$_->{$t}{base}/isolinux.bin") . " 3";
      push @{$mkisofs->{sort}}, "$tmp_new/$_->{$t}{base}/isolinux.bin 3";
      # push @{$mkisofs->{sort}}, "$_->{$t}{base}/isolinux.bin 3";
      push @{$mkisofs->{sort}}, "$tmp_new/$_->{$t}{base} 1";
      $mkisofs->{options} .=
        " -no-emul-boot -boot-load-size 4 -boot-info-table" .
        " -b $_->{$t}{base}/isolinux.bin -c $_->{$t}{base}/boot.catalog" .
        " -hide $_->{$t}{base}/boot.catalog -hide-joliet $_->{$t}{base}/boot.catalog";
      print "El-Torito legacy bootable ($_->{$t}{arch})\n";
      push @$iso_catalog, "Legacy ($_->{$t}{arch})";
    }
    elsif($opt_efi && $t eq 'efi') {
      $has_efi = 1;
      my $f = fname($_->{$t}{base});
      my $s = -s $f;
      $s = (($s + 2047) >> 11) << 2;
      $s = 1 if $s == 0 || $s >> 0xffff;
      push @{$mkisofs->{sort}}, "$f 1000001";
      $mkisofs->{options} .=
        " -eltorito-alt-boot -no-emul-boot -boot-load-size $s -b $_->{$t}{base}";
      print "El-Torito UEFI bootable ($_->{$t}{arch})\n";
      push @$iso_catalog, "UEFI ($_->{$t}{arch})";
      $mkisofs->{fix_catalog} = $iso_catalog;
    }
    elsif($t eq 'ikr') {
      if($_->{$t}{ins}) {
        # need to create base
        create_cd_ikr($_->{$t}{base}, $_->{$t}{ins});
      }
      $mkisofs->{options} .=
        " -eltorito-alt-boot -no-emul-boot -boot-load-size 1 -b $_->{$t}{base}";
      print "El-Torito legacy bootable ($_->{$t}{arch})\n";
      push @$iso_catalog, "Legacy ($_->{$t}{arch})";
      $mkisofs->{fix_catalog} = $iso_catalog;
    }
  }

  if($two_runs) {
    if(open my $fh, ">$tmp_new/glump") {
      print $fh "$magic_id\n";
      close $fh;
    }

    push @{$mkisofs->{sort}}, "$tmp_new/glump 1000000";

    $mkisofs->{options} .= " -hide glump -hide-joliet glump";
  }

  if($mkisofs->{sort}) {
    $mkisofs->{options} .= " -sort '$tmp_sort'";
  }

  if($mkisofs->{exclude}) {
    $mkisofs->{options} .= " -exclude-list '$tmp_exclude'";
  }

  # add our source dirs
  for (@sources) {
    $mkisofs->{options} .= " '$_->{dir}'";
  }
  $mkisofs->{options} .= " '$tmp_new'";
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub run_mkisofs
{
  my $log;
  my $ok;
  my $cmd;

  # create sort file
  if($mkisofs->{sort}) {
    if(open my $fh, ">$tmp_sort") {
      print $fh "$_\n" for @{$mkisofs->{sort}};
      close $fh;
    }
  }

  # create exclude file
  if($mkisofs->{exclude}) {
    if(open my $fh, ">$tmp_exclude") {
      print $fh "$_\n" for @{$mkisofs->{exclude}};
      close $fh;
    }
  }

  $cmd = "$mkisofs->{command}$mkisofs->{options}";

  print "running:\n$cmd\n" if $opt_verbose >= 1;

  print "$mkisofs->{command} sort file:\n", join("\n", @{$mkisofs->{sort}}), "\n" if $opt_verbose >= 2;

  print "$mkisofs->{command} exclude file:\n", join("\n", @{$mkisofs->{exclude}}), "\n" if $opt_verbose >= 2;

  if(open my $fh, "$cmd 2>&1 |") {
    $| = 1;
    $ok = 1;	# sometimes mkisofs doesn't show any progress, so set ok here...
    while(<$fh>) {
      if(/^\s*(\d*\.\d)\d%/) {
        $ok = 1;
        show_progress $1;
      }
      else {
        $log .= $_;
      }
    }
    show_progress 100 if $ok;
    print "\n" if $progress_end == 100;
    close $fh;
    # printf STDERR "ret = $?\n";
    $ok = 0 if $?;
  }

  print $log if $opt_verbose >= 2 || !$ok;

  die "Error: $mkisofs->{command} failed\n" if !$ok;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub read_sector
{
  my $buf;

  die "$iso_file: seek error\n" unless seek($iso_fh, $_[0] * 0x800, 0);
  die "$iso_file: read error\n" if sysread($iso_fh, $buf, 0x800) != 0x800;

  return $buf;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub write_sector
{
  die "$iso_file: seek error\n" unless seek($iso_fh, $_[0] * 0x800, 0);
  die "$iso_file: write error\n" if syswrite($iso_fh, $_[1], 0x800) != 0x800;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub fix_catalog
{
  return unless $mkisofs->{fix_catalog};

  die "$iso_file: $!\n" unless open $iso_fh, "+<", $iso_file;

  my $vol_descr = read_sector 0x10;
  my $vol_id = substr($vol_descr, 0, 7);
  die "$iso_file: not an iso9660 fs\n" if $vol_id ne "\x01CD001\x01";

  my $eltorito_descr = read_sector 0x11;
  my $eltorito_id = substr($eltorito_descr, 0, 0x1e);
  die "$iso_file: not bootable\n" if $eltorito_id ne "\x00CD001\x01EL TORITO SPECIFICATION";

  my $boot_catalog_idx = unpack "V", substr($eltorito_descr, 0x47, 4);
  die "$iso_file: strange boot catalog location: $boot_catalog_idx\n" if $boot_catalog_idx < 0x12;

  my $boot_catalog = read_sector $boot_catalog_idx;

  my $entries = @{$mkisofs->{fix_catalog}};

  my @entry;

  for (my $i = 0; $i < $entries; $i++) {
    push @entry, substr $boot_catalog, 32 * ($i + 1), 32;
    substr($entry[-1], 12, 20) = pack "Ca19", 1, $mkisofs->{fix_catalog}[$i];
    if((unpack "C", $entry[-1])[0] != 0x88) {
      die "$iso_file: boot entry $i: strange content\n";
    }
  }

  substr($boot_catalog, 32 * 1, 32) = $entry[0];

  for (my $i = 1; $i < $entries; $i++) {
    my $section_head = pack "CCva28", $i == $entries - 1 ? 0x91 : 0x90, 0xef, 1, "";
    substr($boot_catalog, 32 * (2 * $i), 32) = $section_head;
    substr($boot_catalog, 32 * (2 * $i + 1), 32) = $entry[$i];
  }

  write_sector $boot_catalog_idx, $boot_catalog;

  close $iso_fh;
  undef $iso_fh;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub relocate_catalog
{
  die "$iso_file: $!\n" unless open $iso_fh, "+<", $iso_file;

  my $vol_descr = read_sector 0x10;
  my $vol_id = substr($vol_descr, 0, 7);
  die "$iso_file: not an iso9660 fs\n" if $vol_id ne "\x01CD001\x01";

  my $path_table = unpack "V", substr($vol_descr, 0x08c, 4);
  die "$iso_file: strange path table location: $path_table\n" if $path_table < 0x11;

  my $new_location = $path_table - 1;

  my $eltorito_descr = read_sector 0x11;
  my $eltorito_id = substr($eltorito_descr, 0, 0x1e);
  die "$iso_file: not bootable\n" if $eltorito_id ne "\x00CD001\x01EL TORITO SPECIFICATION";

  my $boot_catalog_idx = unpack "V", substr($eltorito_descr, 0x47, 4);
  die "$iso_file: strange boot catalog location: $boot_catalog_idx\n" if $boot_catalog_idx < 0x12;

  my $boot_catalog = read_sector $boot_catalog_idx;

  my $vol_descr2 = read_sector $new_location - 1;
  my $vol_id2 = substr($vol_descr2, 0, 7);
  if($vol_id2 ne "\xffCD001\x01") {
    undef $new_location;
    for(my $i = 0x12; $i < 0x40; $i++) {
      $vol_descr2 = read_sector $i;
      $vol_id2 = substr($vol_descr2, 0, 7);
      if($vol_id2 eq "\x00TEA01\x01" || $boot_catalog_idx == $i + 1) {
        $new_location = $i + 1;
        last;
      }
    }
  }

  die "$iso_file: unexpected layout\n" unless defined $new_location;

  # oops, already relocated?
  return if $boot_catalog_idx == $new_location;

  my $version_descr = read_sector $new_location;
  die "$iso_file: unexpected layout\n" if $version_descr ne ("\x00" x 0x800) && substr($version_descr, 0, 4) ne "MKI ";

  # now reloacte to $new_location
  substr($eltorito_descr, 0x47, 4) = pack "V", $new_location;
  write_sector $new_location, $boot_catalog;
  write_sector 0x11, $eltorito_descr;

  printf "boot catalog moved: %d -> %d\n", $boot_catalog_idx, $new_location if $opt_verbose >= 1;

  close $iso_fh;
  undef $iso_fh;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub rerun_mkisofs
{
  my $iso_file_list = isols;
  my $iso_magic = find_magic($iso_file_list);

  die "$iso_file: oops, magic not found\n" unless $iso_magic;

  if($opt_hybrid_fs eq 'iso') {
    meta_iso($iso_magic);
    $progress_start = 50;
  }
  elsif($opt_hybrid_fs eq 'fat') {
    $progress_start = 33;
    $progress_end = 67;
    meta_fat($iso_magic, $iso_file_list);
    $progress_start = 67;
  }

  $progress_end = 100;

  run_mkisofs;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub run_isohybrid
{
  my $opt;
  my $ok;

  $opt .= " --uefi" if $has_efi;
  $opt .= " --gpt" if $opt_hybrid_gpt;
  $opt .= " --mbr" if $opt_hybrid_mbr;
  $opt .= " --offset $mkisofs->{partition_start}" if $mkisofs->{partition_start};

  my $cmd = "isohybrid$opt $iso_file";

  print "running:\n$cmd\n" if $opt_verbose >= 1;

  $ok = !system("$cmd 2>$tmp_err >&2");

  if(open my $fh, "<", $tmp_err) {
    local $/;
    $_ = <$fh>;
    close $fh;
  }

  print $_ if $opt_verbose >= 2 || !$ok;

  die "Error: isohybrid failed\n" if !$ok;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ISO file list sorted by start address.
#
# Return ref to array with files.
#
sub isols
{
  my $files;

  open my $fd, "isoinfo -R -l -i $iso_file 2>/dev/null |";

  my $dir = "/";

  while(<$fd>) {
    if(/^Directory listing of\s*(\/.*\/)/) {
      $dir = $1;
      next;
    }

    if(/^(.)(.*)\s\[\s*(\d+)(\s+\d+)?\]\s+(.*?)\s*$/) {
      my $type = $1;
      my @x = split ' ', $2;
      $type = ' ' if $type eq '-';
      if($5 ne '.' && $5 ne '..') {
        push @$files, { name => "$dir$5", type => $type, start => $3 + 0, size => $x[4] };
      }
    }
  } 

  close $fd;

  $files = [ sort { $a->{start} <=> $b->{start} } @$files ] if $files;

  # we need some more date for fat fs
  if($opt_hybrid_fs eq 'fat') {
    for (my $i = 0; $i < @$files - 1; $i++) {
      next unless $files->[$i]{type} eq ' ';
      my $p = $files->[$i + 1]{start} - $files->[$i]{start} - (($files->[$i]{size} + 0x7ff) >> 11);
      $files->[$i]{pad} = $p if $p > 0;
      my $is_link = $files->[$i + 1]{start} == $files->[$i]{start};
      $files->[$i + 1]{link} = 1 if $is_link;
      if($p < 0) {
        if($is_link) {
          print STDERR "link found: $files->[$i]{name} = $files->[$i+1]{name}\n";
        }
        else {
          die "$files->[$i]{name}: oops, negative padding: $p\n";
        }
      }
    }
  }

  # printf "%6d\t%s %8d %s\n", $_->{start}, $_->{type}, $_->{size}, $_->{name} for @$files;

  return $files;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# find magic block
sub find_magic
{
  my $cnt;
  my $start;
  my $first;

  my $files = shift;

  die "$iso_file: $!\n" unless open $iso_fh, "<", $iso_file;

  found: for (@$files) {
    next unless $_->{type} eq ' ';
    last if $cnt++ >= 8;			# check just first 8 files
    my $buf;
    for (my $i = 0; $i >= -16; $i--) {		# go back up to 16 blocks
      seek $iso_fh, ($_->{start} + $i) << 11, 0;
      sysread $iso_fh, $buf, length $magic_id;
      $start = $_->{start} + $i, last found if $buf eq $magic_id;
    }
  }

  close $iso_fh;

  for (@$files) {
    next unless $_->{type} eq ' ';
    $first = $_->{start};
    last;
  }

  $first = 0 if $first >= $start;

  print "meta data found: first = $first, start = $start\n" if $opt_verbose >= 1;

  return { extra => $first, block => $start };
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub meta_iso
{
  my $magic = shift;

  # copy meta data

  $mkisofs->{partition_start} = $magic->{block} * 4;

  my $blocks = $magic->{block} + 1;
  my $buf;

  die "$iso_file: $!\n" unless open $iso_fh, "<", $iso_file;
  open my $fh, ">", "$tmp_new/glump" or die "$tmp_new/glump: $?\n";

  for (my $i = 0; $i < $blocks; $i++) {
    die "$iso_file: read error\n" unless sysread($iso_fh, $buf, 2048) == 2048;
    die "$tmp_new/glump: write error\n" unless syswrite($fh, $buf, 2048) == 2048;
  }

  close $fh;
  close $iso_fh;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub meta_fat
{
  my $magic = shift;
  my $iso_files = shift;

  my $fat_size;

  my $tmp = $tmp->file('somefile');

  for (reverse @$iso_files) {
    next unless $_->{type} eq ' ';
    $fat_size =  $_->{start} + (($_->{size} + 0x7ff) >> 11);
    last;
  }

  for (@$iso_files) {
    next unless $_->{type} eq 'd';
    $fat_size++;
  }
   
  $fat_size += ($fat_size >> 8) + 4;

  # add a bit free space (4MB)
  $fat_size += 4 << 9;

  # and round up to full MB
  my $fat_mb = ($fat_size + 511) >> 9;

  $fat_size = $fat_mb << 9;

  printf "fat_size = $fat_size\n" if $opt_verbose >= 2;

  open my $fh, ">", $tmp_fat;
  close $fh;
  truncate $tmp_fat, $fat_mb << 20;
  # try fat32 first
  system "mformat -i '$tmp_fat|cylinders=" . $fat_mb * 4 . " heads=16 sectors=32' -c 4 -F -v 'SUSEDVD' :: 2>/dev/null" and
  system "mformat -i '$tmp_fat|cylinders=" . $fat_mb * 4 . " heads=16 sectors=32' -c 4 -v 'SUSEDVD' ::";

  # 1.: directories
  for (@$iso_files) {
    next unless $_->{type} eq 'd';
    system "mmd -i '$tmp_fat' -D o ::$_->{name}";
  }
   
  # 2.: directory entries
  for (@$iso_files) {
    next unless $_->{type} eq ' ';
    system "mcopy -i '$tmp_fat' -D o $tmp ::$_->{name}";
  }

  # 3.: add files
  my $pad = 0;
  my $pad_cnt = 0;
  my $pr_size = (@$iso_files);
  $pr_size = 1 if !$pr_size;
  my $pr_cnt = 0;
  for (@$iso_files) {
    $pr_cnt++;
    next unless $_->{type} eq ' ';
    truncate $tmp, $_->{size};
    system "mcopy -i '$tmp_fat' -D o $tmp ::$_->{name}";
    if($_->{pad}) {
      $pad += $_->{pad};
      truncate $tmp, $pad << 11;
      truncate $tmp, $_->{pad} << 11;
      $pad_cnt++;
      system "mcopy -i '$tmp_fat' -D o $tmp ::padding$pad_cnt";
    }
    show_progress 100 * $pr_cnt / $pr_size;
  }  
     
  system "mdel -i '$tmp_fat' '::padding*'" if $pad;

  # 4.: read file offsets
  for (@$iso_files) {
    $_->{fat} = 0;   
    $_->{fat} = $1 if `mshowfat -i '$tmp_fat' ::$_->{name}` =~ /<(\d+)/;
  }
   
  # 5.: verify file offsets
  my $dif;
  my $first;
  for (@$iso_files) {
    next unless $_->{type} eq ' ' && $_->{fat};
    $first = $_->{fat};
    $dif = $_->{start} - $_->{fat};
    last;
  }
   
  # for (@$iso_files) {
  #   printf "%6d %6d  [%4d]  (%d)\t%s %8d %s\n", $_->{start}, $_->{fat}, $_->{start} - $_->{fat}, $_->{pad} ? $_->{pad} : 0, $_->{type}, $_->{size}, $_->{name};
  # }

  for (@$iso_files) {
    next unless $_->{type} eq ' ' && $_->{fat};
    if($_->{start} - $_->{fat} != $dif) {
      printf STDERR "%6d %6d\t%s %8d %s\n", $_->{start}, $_->{fat}, $_->{type}, $_->{size}, $_->{name};
      die "$_->{name}: wrong fat offset: $dif\n";
    }
  }

  my $last_block;

  for (reverse @$iso_files) {
    next unless $_->{type} eq ' ' && $_->{fat};
    print "last file: $_->{name} $_->{fat}\n" if $opt_verbose >= 2;
    $last_block =  $_->{fat} + (($_->{size} + 0x7ff) >> 11);
    last;
  }

  print "last block: $last_block\n" if $opt_verbose >= 2;


  my $data_start;
  for (`dosfsck -v '$tmp_fat'`) {
    if(/Data area starts at byte (\d+)/) {
      $data_start = $1 + (($first - 2) << 11);
      $last_block = ($1 >> 9) + (($last_block - 2) << 2);
    }
  }

  printf "last_block = $last_block\n" if $opt_verbose >= 2;

  my $iso_pad = (($fat_size << 2) - $last_block) >> 2;

  die "$tmp_fat: oops, data start not found\n" unless $data_start;

  print "data start = $data_start\n" if $opt_verbose >= 2;

  truncate $tmp_fat, $data_start;

  my $align = ($data_start & 0x7ff) >> 9;
  $align = (4 - $align) & 3;

  if($align) {
    print "alignment needed: $align\n" if $opt_verbose >= 2;
    $iso_pad++;
  }
   
  printf "iso_pad = $iso_pad\n" if $opt_verbose >= 2;

  $mkisofs->{partition_start} = ($magic->{block} << 2) + $align;

  # now copy the fat

  open my $fh, ">", "$tmp_new/glump";

  seek $fh, $align << 9, 0;

  open my $fat_fh, $tmp_fat;

  for (my $i = 0; $i < $data_start >> 20; $i++) {
    my $buf;
    sysread $fat_fh, $buf, 1 << 20;
    syswrite $fh, $buf, 1 << 20;
  }

  if(my $i = $data_start & ((1 << 20) - 1)) {
    my $buf;
    sysread $fat_fh, $buf, $i;
    syswrite $fh, $buf, $i;
  }

  close $fat_fh;

  if($magic->{extra}) {
    my $buf;
    open $iso_fh, $iso_file;
    seek $iso_fh, $magic->{extra} << 11, 0;
    for (my $i = $magic->{extra}; $i < $magic->{block} + 1; $i++) {
      sysread $iso_fh, $buf, 0x800;
      syswrite $fh, $buf, 0x800;
    }
    close $iso_fh;
  }

  close $fh;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub create_initrd
{
  return undef if !@opt_initrds;

  my $tmp_initrd = $tmp->file();
  my $tmp_dir = $tmp->dir();

  for my $i (@opt_initrds) {
    my $t = `file -b -k -L $i 2>/dev/null`;
    if(-d $i) {
      system "tar -C '$i' -cf - . | tar -C $tmp_dir -xpf -";
    }
    elsif(-f $i && $t =~ /^RPM/) {
      system "rpm2cpio '$i' | ( cd $tmp_dir ; cpio --quiet --sparse -dimu --no-absolute-filenames )";
    }
    else {
      print STDERR "Warning: ignoring $i\n";
    }
  }

  if($opt_no_docs) {
    system "rm -rf $tmp_dir/usr/share/{doc,info,man}";
    rmdir "$tmp_dir/usr/share";
    rmdir "$tmp_dir/usr";
  }

  # make it possible to directly add linuxrc.rpm - it's a bit special
  if(-f "$tmp_dir/usr/sbin/linuxrc") {
    rename "$tmp_dir/usr/sbin/linuxrc", "$tmp_dir/init";
    print "initrd: linuxrc detected, renamed to /init\n";
  }

  system "( cd $tmp_dir; find . | cpio --quiet -o -H newc | gzip -9c ) >> $tmp_initrd";

  # system "ls -lR $tmp_dir";

  return $tmp_initrd;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub update_initrd
{
  return if !$add_initrd;

  for my $b (sort keys %$boot) {
    if($boot->{$b}{initrd}) {
      my $n = copy_file $boot->{$b}{initrd};
      if(-f $n) {
        system "cat $add_initrd >> $n";
      }
      last;
    }
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub create_cd_ikr
{
  local $_;

  my $ikr = $_[0];
  my $ins = $_[1];

  my $src = fname($ins);
  $src =~ s#/[^/]*$##;

  my $dst = $ikr;
  $dst =~ s#/[^/]*$##;

  my @layout;

  if(open my $s, fname($ins)) {
    while(<$s>) {
      next if /^\s*\*/;
      push @layout, { file => "$src/$1", ofs => oct($2) } if /^\s*(\S+)\s+(\S+)/;
    }
    close $s;
  }

  die "$ins: nothing to do?\n" if !@layout;

  system("mkdir -p $tmp_new/$dst");

  if(open my $d, ">", "$tmp_new/$ikr") {
    for (@layout) {
      my $fname = $_->{file};
      my $is_parmfile;
      $is_parmfile = 1 if $fname =~ s#(/parmfile)$#$1.cd#;
      if(open my $f, $fname) {
        sysread $f, my $buf, -s($f);
        close $f;
        sysseek $d, $_->{ofs}, 0;
        # remove newlines from parmfile
        $buf =~ s/\n+/ /g if $is_parmfile;
        syswrite $d, $buf;
        # print "$fname: $_->{ofs} ", length($buf), "\n";
      }
      else {
        die "$_->{file}: $!\n";
      }
    }

    sysseek $d, 4, 0;
    syswrite $d, pack("N",0x80010000);

    # align to 4k
    sysseek $d, -s($d) | 0xfff, 0;
    syswrite $d, "\x00";

    close $d;
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub isolinux_add_option
{
  my $n = shift;
  my $b = shift;

  if(open my $f, $n) {
    my @f = <$f>;
    close $f;
    @f = map { chomp; $_ .= " $b" if /^\s*append\s.*initrd=/; "$_\n" } @f;
    if(open my $f, ">", $n) {
      print $f @f;
      close $f;
    }
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub grub2_add_option
{
  my $n = shift;
  my $b = shift;

  if(open my $f, $n) {
    my @f = <$f>;
    close $f;
    @f = map { chomp; $_ .= " $b" if /^\s*linuxefi\s/; "$_\n" } @f;
    if(open my $f, ">", $n) {
      print $f @f;
      close $f;
    }
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub update_boot_options
{
  return unless defined $opt_boot_options;

  # print Dumper($boot);

  for my $b (sort keys %$boot) {
    if($boot->{$b}{bl}{isolinux}) {
      my $n = copy_file "$boot->{$b}{bl}{isolinux}{base}/isolinux.cfg";
      isolinux_add_option $n, $opt_boot_options;
    }
    if($boot->{$b}{bl}{efi}) {
      my $n = copy_file $boot->{$b}{bl}{efi}{base};
      if(defined $n) {
        my $tmp = $tmp->file();
        if(!system "mcopy -n -i $n ::/efi/boot/grub.cfg $tmp") {
          grub2_add_option $tmp, $opt_boot_options;
          if(system "mcopy -D o -i $n $tmp ::/efi/boot/grub.cfg") {
            print STDERR "Warning: failed to update grub.cfg\n";
          }
        }
      }
    }
    if($b eq 'efi') {
      my $n = copy_file "$boot->{$b}{base}/grub.cfg";
      grub2_add_option $n, $opt_boot_options;
    }
  }
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub prepare_micro
{
  my $p = $files->{boot};
  # try harder, just in case
  $p = $files->{suse} unless  defined $p;

  push @{$mkisofs->{exclude}}, "$p/suse/$_" for (@boot_archs, "i586", "noarch");

  push @{$mkisofs->{exclude}}, (
    "$p/docu",
    "$p/ls-lR.gz",
    "$p/INDEX.gz",
    "$p/ARCHIVES.gz",
    "$p/ChangeLog",
    "$p/updates",
    "$p/linux",
  );
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub prepare_nano
{
  prepare_micro;

  my $p = $files->{boot};
  # try harder, just in case
  $p = $files->{suse} unless  defined $p;

  return unless defined $p;

  push @{$mkisofs->{exclude}}, (
    "$p/suse",
    "$p/boot/*/*.rpm",
    "$p/boot/*/bind",
    "$p/boot/*/common",
    "$p/boot/*/gdb",
    "$p/boot/*/rescue",
    "$p/boot/*/root",
    "$p/boot/*/sax2",
    "$p/boot/*/branding",
    "$p/boot/*/openSUSE",
    "$p/boot/*/SLES",
    "$p/boot/*/SLED",
    "$p/boot/*/*-xen",
    "$p/control.xml",
    "$p/gpg-*",
    "$p/NEWS",
    "TRANS.TBL",
  );
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub prepare_pico
{
  prepare_nano;

  my $p = $files->{boot};
  # try harder, just in case
  $p = $files->{suse} unless  defined $p;

  return unless defined $p;

  push @{$mkisofs->{exclude}}, (
    "$p/boot/*/*/linux",
    "$p/boot/*/*/initrd",
    "$p/boot/*/*/biostest",
    "$p/boot/*/*/en.tlk",
    "$p/EFI",
    "$p/boot/*/efi",
    "$p/boot/*/grub2*",
  );
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub set_mkisofs_metadata
{
  my $media;

  # first, try using old values, if we remaster an image
  if($sources[0]{type} eq 'iso') {
    if(open my $f, "isoinfo -d -i $sources[0]{real_name} 2>/dev/null |") {
      while(<$f>) {
        $opt_volume = $1 if !defined $opt_volume && /^Volume id:\s*(.*?)\s*$/ && $1 ne "" && $1 ne "CDROM";
        $opt_vendor = $1 if !defined $opt_vendor && /^Publisher id:\s*(.*?)\s*$/ && $1 ne "";
        $opt_application = $1 if !defined $opt_application && /^Application id:\s*(.*?)\s*$/ && $1 ne "";
        $opt_preparer = $1 if !defined $opt_preparer && /^Data preparer id:\s*(.*?)\s*$/ && $1 ne "";
      }
      close $f;
      undef $opt_application if $opt_application =~ /^GENISOIMAGE/;
    }
  }

  # else, build new ones based on media.1 dir
  for (sort sort keys %$files) {
    $media = $_, last if /^media\.\d+$/;
  }

  if($media) {
    if(open my $f, "<", fname("$media/build")) {
      my $x = <$f>;
      close $f;
      chomp $x;
      my $m .= $1 if $media =~ /\.(\d+)$/;
      if(!defined $opt_application) {
        $opt_application = $x;
        $opt_application .= "-Media$m" if defined $m;
      }
      if(!defined $opt_volume) {
        $opt_volume = $x;
        $opt_volume =~ s/\-?Build.*$//;
        # try to cut volume id to fit into 32 bytes
        while(length $opt_volume > 25 && $opt_volume =~ s/\-([^\-])*$//) {}
        $opt_volume .= "-Media$m" if defined $m;
      }
    }

    if(open my $f, "<", fname("$media/media")) {
      my $x = <$f>;
      close $f;
      chomp $x;
      $x = "SUSE LINUX GmbH" if $x eq "SUSE" || $x eq "openSUSE";
      $opt_vendor = $x if $x ne "" && !defined $opt_vendor;
    }

    if(open my $f, "<", fname("$media/info.txt")) {
      local $/;
      my $x = <$f>;
      close $f;
      if($x =~ /\n([^\n]+)\n\s*$/) {
        $x = $1;
        $x =~ s/^\s*|\s*$//g;
        $x =~ s/\.//;
        $opt_preparer = $x if $x ne "" && !defined $opt_preparer;
      }
    }
  }

  # if nothing worked, put in some defaults
  $opt_vendor = "mksusecd $VERSION" if !defined $opt_vendor;
  $opt_preparer = "mksusecd $VERSION" if !defined $opt_preparer;
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub update_content
{
  my $content = fname "content";

  return unless defined $content;

  my $content_old;
  my $content_new;

  if(open(my $f, $content)) {
    while(<$f>) {
      $content_old .= $_;
      if(/^((META|HASH|KEY)\s+SHA(\d+)\s+)(\S+)(\s+(\S+))/) {
        my $bits  = "\L$3";
        my $val = "\L$4";
        my $name = "$6";
        my $part1 = $1;
        my $part2 = $5;
        # print "bits = $bits, val = $val, name = $name\n";
        # print "($part1)($part2)\n";
        my $digest = Digest::SHA->new($bits);
        my $f = fname $name;
        if(defined $f) {
          $digest->addfile($f);
          $val = $digest->hexdigest;
        }
        $content_new .= "$part1$val$part2\n";
      }
      else {
        $content_new .= $_;
      }
    }
    close $f;
  }

  if($content_new ne $content_old) {
    my $n = copy_file "content";

    if($n) {
      if(open my $f, ">", $n) {
        print $f $content_new;
        close $f;
      }
    }
  }
}

